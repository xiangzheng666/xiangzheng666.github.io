[
  {
    "title": "爬虫 浏览器",
    "url": "/posts/%E7%88%AC%E8%99%AB-%E6%B5%8F%E8%A7%88%E5%99%A8/",
    "categories": "爬虫",
    "tags": "浏览器",
    "date": "2024-05-12 00:00:00 +0800",
    "content": "浏览器控制 1.Selenium pip install selenium  #浏览器版本： chrome://version/  #chromedrive下载 https://registry.npmmirror.com/binary.html?path=chromedriver/ https://googlechromelabs.github.io/chrome-for-testing/..."
  },
  {
    "title": "爬虫 M3u8",
    "url": "/posts/%E7%88%AC%E8%99%AB-m3u8/",
    "categories": "爬虫",
    "tags": "爬虫",
    "date": "2024-05-11 00:00:00 +0800",
    "content": "HLS HLS技术的特点是将流媒体切分为若干【TS片段】（比如几秒一段），然后通过一个【M3U8列表文件】将这些TS片段批量下载供客户端播放器实现实时流式播放.  M3U文件 #EXTM3U:每个M3U文件第一行必须是这个tag标识。(简单了解) #EXT-X-VERSION:版本，此属性可用可不用。(简单了解) #EXT-X-TARGETDURATION:目标持续时间，是用来定义每个TS的..."
  },
  {
    "title": "逆向 抓包",
    "url": "/posts/%E9%80%86%E5%90%91-%E6%8A%93%E5%8C%85/",
    "categories": "逆向",
    "tags": "抓包",
    "date": "2024-05-08 00:00:00 +0800",
    "content": "Flutter对抗    Dart语言标准库的网络请求不走Wi-Fi代{过}{滤}理：Flutter使用的是Dart语言，其标准库中的网络请求不会通过代{过}{滤}理发送，这与许多其他应用不同。常规的抓包工具通常依赖于代{过}{滤}理来捕获网络流量，因此无法捕获Flutter应用的网络请求。   Dart SDK中的证书信任：Dart SDK在Android平台上强制只信任系统目录下的证书。..."
  },
  {
    "title": "逆向 签名校验",
    "url": "/posts/%E9%80%86%E5%90%91-%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C/",
    "categories": "逆向",
    "tags": "签名",
    "date": "2024-04-28 00:00:00 +0800",
    "content": "签名 没有被签名的 Apk，则会被拒绝安装  Android 目前支持以下四种应用签名方案：    v1 方案：基于 JAR 签名。    v2 方案：APK 签名方案 v2（在 Android 7.0 中引入）    v3 方案：APK 签名方案 v3（在 Android 9 中引入）    v4 方案：APK 签名方案 v4（在 Android 11 中引入）  V1 签名的机制三个文件..."
  },
  {
    "title": "逆向 Frida持久化",
    "url": "/posts/%E9%80%86%E5%90%91-frida%E6%8C%81%E4%B9%85%E5%8C%96/",
    "categories": "逆向",
    "tags": "frida",
    "date": "2024-04-22 00:00:00 +0800",
    "content": "1.免root方案 Frida的Gadget是一个共享库，用于免root注入hook脚本。    官方文档   思路:将APK解包后，通过修改smali代码或patch so文件的方式植入frida-gadget，然后重新打包安装。   优点:免ROOT、能过掉一部分检测机制   缺点:重打包可能会遇到解决不了的签名校验、hook时机需要把握          基于obejction的pat..."
  },
  {
    "title": "逆向 Frida检测",
    "url": "/posts/%E9%80%86%E5%90%91-frida%E6%A3%80%E6%B5%8B/",
    "categories": "逆向",
    "tags": "frida",
    "date": "2024-04-19 00:00:00 +0800",
    "content": "1.检测文件名、端口名、双进程保护、失效的检测点 1.检测/data/local/tmp路径下的是否有frida特征文件，server端改名，例如:fr    2.指定端口转发  复制代码 隐藏代码 ./fs1 -l 0.0.0.0:6666 adb forward tcp:6666 tcp:6666 frida -H 127.0.0.1:6666 wuaipojie -l hook.js ..."
  },
  {
    "title": "逆向 Root,xposed检测",
    "url": "/posts/%E9%80%86%E5%90%91-root,xposed%E6%A3%80%E6%B5%8B/",
    "categories": "逆向",
    "tags": "Xposed",
    "date": "2024-04-18 00:00:00 +0800",
    "content": "检查文件系统中的根目录路径：    /system/app/SuperSU/   /system/xbin/su   /sbin/su   /system/bin/su   检查 su 命令 su 命令是 Android 上 root 权限的标志，检测设备是否有 su 命令可以执行。  常见的 Xposed 文件路径：    /data/data/de.robv.android.xposed..."
  },
  {
    "title": "逆向 Frida everything",
    "url": "/posts/%E9%80%86%E5%90%91-frida-everything/",
    "categories": "逆向",
    "tags": "frida",
    "date": "2024-04-18 00:00:00 +0800",
    "content": "使用 1.上传指定frida server  2.运行frida命令hook  1.基础指令 1.frida-ps -U  查看当前手机运行的进程    2.frida-ps --help 查看help指令  Spawn模式  复制代码 隐藏代码 frida -U -f 进程名 -l hook.js   attach模式 ：  复制代码 隐藏代码 frida -U 进程名 -l hook.j..."
  },
  {
    "title": "逆向 Xposed",
    "url": "/posts/%E9%80%86%E5%90%91-Xposed/",
    "categories": "逆向",
    "tags": "Xposed",
    "date": "2024-04-08 00:00:00 +0800",
    "content": "Xposed常用AP 1.Hook普通方法 修改返回值  复制代码 隐藏代码 XposedHelpers.findAndHookMethod(&quot;com.zj.wuaipojie.Demo&quot;, loadPackageParam.classLoader, &quot;a&quot;, String.class, new XC_MethodHook() {     @Override     protected vo..."
  },
  {
    "title": "逆向 代码分析",
    "url": "/posts/%E9%80%86%E5%90%91-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/",
    "categories": "逆向",
    "tags": "静态分析",
    "date": "2024-03-28 00:00:00 +0800",
    "content": "静态分析jadx 一个静态反编译工具  搜索     查找用例，赋值片段   反混淆   动态调试jeb 1.修改debug权限         1.android:debuggable=&quot;true&quot;           2.XappDebug模块hook对应的app           3刷入MagiskHide Props Config模块                       2..."
  },
  {
    "title": "逆向 搜索目标",
    "url": "/posts/%E9%80%86%E5%90%91-%E6%90%9C%E7%B4%A2%E7%9B%AE%E6%A0%87/",
    "categories": "逆向",
    "tags": "搜索",
    "date": "2024-03-18 00:00:00 +0800",
    "content": "查找目标字符串位置   1.组件上的直接赋值的   直接在xml中就可以搜索到    2.组件上用id替代的   xml搜索不到                去资源索引中找      3.代码赋值的在dex中查找     在找不到，去ida里面找  查找图片地址   与上述字符串的查找思路类似  获取id-》查id-》看是否用id代理-》代理就在资源索引中查找"
  },
  {
    "title": "逆向 安卓开发思维",
    "url": "/posts/%E9%80%86%E5%90%91-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E6%80%9D%E7%BB%B4/",
    "categories": "逆向",
    "tags": "安卓",
    "date": "2024-03-08 00:00:00 +0800",
    "content": "安卓项目搭建 1.andoridstudio安装，接外网  2.新建项目    **1. ****manifests**    作用：存放应用的AndroidManifest.xml文件。            该文件是Android应用的配置文件，包含应用的基本信息，如包名、权限、Activity、Service等组件的声明。       Android系统会根据这个文件来识别和加载应用。..."
  },
  {
    "title": "Mysql45讲 重新认识锁",
    "url": "/posts/mysql45%E8%AE%B2-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E9%94%81/",
    "categories": "redis",
    "tags": "redis",
    "date": "2023-10-28 00:00:00 +0800",
    "content": ""
  },
  {
    "title": "Mysql45讲 重新认识索引",
    "url": "/posts/mysql45%E8%AE%B2-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E7%B4%A2%E5%BC%95/",
    "categories": "redis",
    "tags": "redis",
    "date": "2023-10-18 00:00:00 +0800",
    "content": ""
  },
  {
    "title": "Mysql45讲 重新认识sql",
    "url": "/posts/mysql45%E8%AE%B2-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86sql/",
    "categories": "redis",
    "tags": "redis",
    "date": "2023-10-08 00:00:00 +0800",
    "content": ""
  },
  {
    "title": "Redis设计与实战 数据库行为",
    "url": "/posts/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E6%88%98-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%8C%E4%B8%BA/",
    "categories": "redis",
    "tags": "redis",
    "date": "2023-09-08 00:00:00 +0800",
    "content": ""
  },
  {
    "title": "Redis设计与实战 数据结构",
    "url": "/posts/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E6%88%98-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",
    "categories": "redis",
    "tags": "redis",
    "date": "2023-08-28 00:00:00 +0800",
    "content": "Redis简单动态字符串SDS  Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。  struct sdshdr {    // 记录 buf 数组中已使用字节的数量     // 等于..."
  },
  {
    "title": "Redis设计与实战 Redis实战功能",
    "url": "/posts/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E6%88%98-redis%E5%AE%9E%E6%88%98%E5%8A%9F%E8%83%BD/",
    "categories": "redis",
    "tags": "redis",
    "date": "2023-08-28 00:00:00 +0800",
    "content": ""
  },
  {
    "title": "Windows_ros_ Xacrof文件",
    "url": "/posts/windows_ros_-xacrof%E6%96%87%E4%BB%B6/",
    "categories": "windows_ros",
    "tags": "xacro",
    "date": "2023-08-13 00:00:00 +0800",
    "content": "xacro文件          使用      &amp;lt;!-- 根标签，必须声明 xmlns:xacro --&amp;gt; &amp;lt;robot name=&quot;my_base&quot; xmlns:xacro=&quot;http://www.ros.org/wiki/xacro&quot;&amp;gt;           先要转化成urdf：rosun xacro xacro xxx.xacro &amp;gt; xxx.urdf 在..."
  },
  {
    "title": "Windows_ros_ Urdf文件",
    "url": "/posts/windows_ros_-urdf%E6%96%87%E4%BB%B6/",
    "categories": "windows_ros",
    "tags": "urdf",
    "date": "2023-07-13 00:00:00 +0800",
    "content": "urdf文件     使用      在ns中设置一个参数            在rviz或者gazebo中加载                   语法    单位：米制                      &amp;lt;robot name=&quot;robot_name&quot;&amp;gt;                       ```xml 1.&amp;lt;link “刚体部分”/&amp;gt;     ..."
  },
  {
    "title": "Windows_ros_ Roslaunch",
    "url": "/posts/windows_ros_-roslaunch/",
    "categories": "windows_ros",
    "tags": "roslaunch",
    "date": "2023-06-13 00:00:00 +0800",
    "content": "launch文件使用     调用     roslaunch 包名 xxx.launch            注意:roslaunch 命令执行launch文件时，首先会判断是否启动了 roscore,如果启动了，则不再启动，否则，会自动调用 roscore                文件标签                      &amp;lt;launch&amp;gt; &amp;lt;launc..."
  },
  {
    "title": "Windows_ros_运行管理",
    "url": "/posts/windows_ros_%E8%BF%90%E8%A1%8C%E7%AE%A1%E7%90%86/",
    "categories": "windows_ros",
    "tags": "元功能",
    "date": "2023-05-22 00:00:00 +0800",
    "content": "ROS元功能包           star*3     场景:完成ROS中一个系统性的功能，可能涉及到多个功能包，比如实现了机器人导航模块，该模块下有地图、定位、路径规划…等不同的子级功能包。那么调用者安装该模块时，需要逐一的安装每一个功能包吗？   显而易见的，逐一安装功能包的效率低下，在ROS中，提供了一种方式可以将不同的功能包打包成一个功能包，当安装某个功能模块时，直接调用打包后的功..."
  },
  {
    "title": "Windows_ros_文件结构",
    "url": "/posts/windows_ros_%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/",
    "categories": "windows_ros",
    "tags": "ros",
    "date": "2023-05-12 00:00:00 +0800",
    "content": "1.概念     这是书上的                   WorkSpace --- 自定义的工作空间        |--- build:编译空间，用于存放CMake和catkin的缓存信息、配置信息和其他中间文件。        |--- devel:开发空间，用于存放编译后生成的目标文件，包括头文件、动态&amp;amp;静态链接库、可执行文件等。        |--- src: 源..."
  },
  {
    "title": "Windows_ros_模块导入",
    "url": "/posts/windows_ros_%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5/",
    "categories": "windows_ros",
    "tags": "模块",
    "date": "2023-04-12 00:00:00 +0800",
    "content": "Python模块导入  与C++类似的，在Python中导入其他模块时，也需要相关处理。  需求:首先新建一个Python文件A，再创建Python文件UseA，在UseA中导入A并调用A的实现。  实现:     新建两个Python文件，使用 import 实现导入关系；   添加可执行权限、编辑配置文件并执行UseA。     1.新建两个Python文件并使用import导入  文件..."
  },
  {
    "title": "Windows_ros_通信学习 ",
    "url": "/posts/windows_ros_%E9%80%9A%E4%BF%A1%E5%AD%A6%E4%B9%A0/",
    "categories": "windows_ros",
    "tags": "通信",
    "date": "2023-04-01 00:00:00 +0800",
    "content": "1.话题通信            建立依赖             package.xml        ​	message_generation        ​	message_runtime        cmakelist.txt        ​	find_package( …… message_generation)        ​	catkin_package(CATKIN..."
  },
  {
    "title": "Windows_ros Topic_msg实验",
    "url": "/posts/windows_ros-topic_msg%E5%AE%9E%E9%AA%8C/",
    "categories": "windows_ros",
    "tags": "rospy",
    "date": "2023-03-11 00:00:00 +0800",
    "content": "编写py  \# coding：&amp;lt;encoding name&amp;gt; ： # coding: utf-8  import rospy  from hello.msg import Person  def doPerson(p):    print(&quot;lisnten:name:%s, age:%d, height:%.2f\n&quot;,p.name, p.age, p.height)    \..."
  },
  {
    "title": "Windows_ros Sevice_srv实验 ",
    "url": "/posts/windows_ros-sevice_srv%E5%AE%9E%E9%AA%8C/",
    "categories": "windows_ros",
    "tags": "ROS",
    "date": "2023-02-28 00:00:00 +0800",
    "content": "# coding：&amp;lt;encoding name&amp;gt; ： # coding: utf-8  import rospy  from one.srv import test  import sys    if __name__ == &quot;__main__&quot;:    \# 2.初始化 ROS 节点    rospy.init_node(&quot;AddInts_Client_p&quot;)    \# 3...."
  },
  {
    "title": "Windows_ros Parame实验",
    "url": "/posts/windows_ros-parame%E5%AE%9E%E9%AA%8C/",
    "categories": "windows_ros",
    "tags": "rospy",
    "date": "2023-02-21 00:00:00 +0800",
    "content": "import rospy if __name__ == &quot;__main__&quot;:     rospy.init_node(&quot;get_param_p&quot;)     a=rospy.get_param(&#39;a&#39;,1000)     rospy.loginfo(&quot;date_a:%d&quot;,a)     b=rospy.get_param_cached(&#39;b&#39;)     rospy.loginfo(&quot;cach..."
  },
  {
    "title": "Windows_ros 计算图",
    "url": "/posts/windows_ros-%E8%AE%A1%E7%AE%97%E5%9B%BE/",
    "categories": "windows_ros",
    "tags": "计算图",
    "date": "2023-02-10 00:00:00 +0800",
    "content": "1.  计算图（Computation Graph）](http://wiki.ros.org/cn/ROS/Concepts#ROS.2Bi6F7l1b.2BXEJrIQ-)是一个由ROS进程组成的点对点网络，它们能够共同处理数据。ROS的基本计算图概念有节点（Nodes）、主节点（Master）、参数服务器（Parameter Server）、消息（Messages）、服务（Servic..."
  },
  {
    "title": "Windows_ros 环境搭建",
    "url": "/posts/windows_ros-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/",
    "categories": "windows_ros",
    "tags": "Ros",
    "date": "2023-02-09 00:00:00 +0800",
    "content": "Ros安装          采用官网roswiki步骤           离线安装      Ros依赖安装  使用choco安装二进制文件  下载源码进行编译，并把devel/setup.bat激活     编译源码，生成lib   choco install ros-melodic-一般没有   下载git源码注意branch   lib not find            文件..."
  },
  {
    "title": "视觉slam 空间点与像素平面1",
    "url": "/posts/%E8%A7%86%E8%A7%89slam-%E7%A9%BA%E9%97%B4%E7%82%B9%E4%B8%8E%E5%83%8F%E7%B4%A0%E5%B9%B3%E9%9D%A21/",
    "categories": "视觉slam",
    "tags": "相机模型",
    "date": "2023-01-15 00:00:00 +0800",
    "content": "空间点与像素平面          针孔相机模型                      空间点:X,Y,Z                       坐标比例：Z/f=-X/X‘=-Y/Y’                       成像平面                     成像平面点:X’,Y’           X’=f*X/Z           Y’=f*Y/Z  ..."
  },
  {
    "title": "视觉slam 视觉里程计",
    "url": "/posts/%E8%A7%86%E8%A7%89slam-%E8%A7%86%E8%A7%89%E9%87%8C%E7%A8%8B%E8%AE%A1/",
    "categories": "视觉slam",
    "tags": "视觉里程计",
    "date": "2023-01-13 00:00:00 +0800",
    "content": "视觉里程计     特征=关键点+描述子            ORB特征                    oriented fast关键点：半径为r的圆上的点的值与该点的差异，fast12是运用于快速排除非关键点           brief描述子：二进制的形式，关键点附件的随机两点大小                       特征匹配                    暴..."
  },
  {
    "title": "视觉slam 非线性优化",
    "url": "/posts/%E8%A7%86%E8%A7%89slam-%E9%9D%9E%E7%BA%BF%E6%80%A7%E4%BC%98%E5%8C%96/",
    "categories": "视觉slam",
    "tags": "非线性优化",
    "date": "2023-01-12 00:00:00 +0800",
    "content": "非线性优化          这个优化是解决slam传感器的噪音问题的，对传感器得到的数据推断的姿态进行优化           概率问题                      在当前传感器的读数下，相机在哪种位姿与路标在哪个位置的概率最大即：                       问题转化即选出x，y使得P(x,y/z,u)最大                          ..."
  },
  {
    "title": "视觉slam 空间点与像素空间2",
    "url": "/posts/%E8%A7%86%E8%A7%89slam-%E7%A9%BA%E9%97%B4%E7%82%B9%E4%B8%8E%E5%83%8F%E7%B4%A0%E7%A9%BA%E9%97%B42/",
    "categories": "视觉slam",
    "tags": "像素, 相机成像",
    "date": "2023-01-11 00:00:00 +0800",
    "content": "空间点与像素空间     双目相机成像原理            对于单目相机，一个像素点对应一条射线上的点，双目相机只在x轴上有平移，对于一个观测物体具有两条射线，两条射线就确定了深度信息              得到深度信息 z=f*b/d       其中 视差d，需要知道左相机的每个像素点(xl, yl)和右相机中对应点(xr, yr)的对应关系。这是双目视觉的核心问题。x坐标之差..."
  },
  {
    "title": "视觉slam 李群与李代数",
    "url": "/posts/%E8%A7%86%E8%A7%89slam-%E6%9D%8E%E7%BE%A4%E4%B8%8E%E6%9D%8E%E4%BB%A3%E6%95%B0/",
    "categories": "视觉slam",
    "tags": "李群, 李代数",
    "date": "2023-01-10 00:00:00 +0800",
    "content": "李群与李代数     首先了解了什么是            群（集合，运算 满足 封结幺逆）       李群（连续的群）       李代数（流行李群在单位元附件的正切空间的投影，实际上是旋转向量组成的空间）       李群于李代数一一对应           李群与李代数的关系            S0(3)==&amp;gt;so(3)     :ln ,^       so(3)==&amp;..."
  },
  {
    "title": "视觉slam 物体位姿的表示",
    "url": "/posts/%E8%A7%86%E8%A7%89slam-%E7%89%A9%E4%BD%93%E4%BD%8D%E5%A7%BF%E7%9A%84%E8%A1%A8%E7%A4%BA/",
    "categories": "视觉slam",
    "tags": "位姿",
    "date": "2023-01-09 00:00:00 +0800",
    "content": "物体位姿的表示     三维空间刚体运动包括旋转与平移   旋转表示            旋转矩阵： 通过俩个三维世界坐标系下两组不重复，同原点的正交基组成的一个正交矩阵，计为SO(3) R                    变换矩阵：由旋转矩阵加上平移信息得到的，计为SE(3) T                       旋转向量：由世界坐标系下的的一个旋转轴与旋转角组成V,角度..."
  },
  {
    "title": "视觉slam Slam介绍",
    "url": "/posts/%E8%A7%86%E8%A7%89slam-slam%E4%BB%8B%E7%BB%8D/",
    "categories": "视觉slam",
    "tags": "SLAM",
    "date": "2023-01-08 00:00:00 +0800",
    "content": "SLAM是什么          视觉slam是依靠摄像机类的传感器对图像序列数据，进行环境感知，相机定位并且常见的图像数据有单目，双目；rgb与rgb-d图像           视觉slam的一般流程：1.传感器采集数据，2.前端里程计（估计运动，可能会造成累计漂移），3.后端优化（对这个slam系统接受，产生的信息进行优化，精确定位，建图），4.回环检测（判断是否先前来过，作用是将该信..."
  },
  {
    "title": "Javaee Cloud_duojihuancun",
    "url": "/posts/JAVAEE-cloud_duojihuancun/",
    "categories": "javaEE",
    "tags": "缓存, 多级缓存",
    "date": "2022-12-23 00:00:00 +0800",
    "content": "多级缓存          多级缓存             浏览器访问静态资源时，优先读取浏览器本地缓存       访问非静态资源（ajax查询数据）时，访问服务端       请求到达Nginx后，优先读取Nginx本地缓存       如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）       如果Redis查询未命中，则查询Tomcat       请求..."
  },
  {
    "title": "Javaee Cloud_es",
    "url": "/posts/JAVAEE-cloud_ES/",
    "categories": "javaEE",
    "tags": "ElasticSearch",
    "date": "2022-12-20 00:00:00 +0800",
    "content": "ElasticSearch     ELK技术栈            kibana       Logstash       Beats                elasticsearch底层是基于lucene来实现的。Lucene是一个Java语言的搜索引擎类库      正向和倒排            正向索引是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个..."
  },
  {
    "title": "Javaee Cloud_protect",
    "url": "/posts/JAVAEE-cloud_protect/",
    "categories": "javaEE",
    "tags": "雪崩",
    "date": "2022-12-15 00:00:00 +0800",
    "content": "Sentinel          雪崩问题             超时处理       仓壁模式       断路器       限流                sentinel                      https://sentinelguard.io/zh-cn/index.html                       https://github.com..."
  },
  {
    "title": "Javaee Cloud_transtion",
    "url": "/posts/JAVAEE-cloud_transtion/",
    "categories": "javaEE",
    "tags": "事务",
    "date": "2022-12-09 00:00:00 +0800",
    "content": "Seata          分布式事务解决方案                      BASE理论          BASE理论是对CAP的一种解决思路                     Basically Available （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。           Soft State（软状态）：在一定时间内，允许出现中..."
  },
  {
    "title": "Javaee Cloud_huancun",
    "url": "/posts/JAVAEE-cloud_huancun/",
    "categories": "javaEE",
    "tags": "缓存",
    "date": "2022-12-03 00:00:00 +0800",
    "content": "分布式缓存  1.Redis持久化          RDB持久化             把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件                RDB持久化在四种情况下会执行：                     执行save命令           执行bgsave命令           R..."
  },
  {
    "title": "Javaee Cloud",
    "url": "/posts/JAVAEE-cloud/",
    "categories": "javaEE",
    "tags": "cloud",
    "date": "2022-12-01 00:00:00 +0800",
    "content": "cloud     –》》            单体架构       分布式架构       微服务                words                      服务拆分                       远程调用                       服务注册                                  @Bean @Load..."
  },
  {
    "title": "Javaee Springboot",
    "url": "/posts/JAVAEE-springboot/",
    "categories": "javaEE",
    "tags": "springboot",
    "date": "2022-11-21 00:00:00 +0800",
    "content": "springboot          步骤                      使用idea创建springboot                       定义开发类                       @RestController @RequestMapping(&quot;/books&quot;) public class BookController {     @GetMapp..."
  },
  {
    "title": "Javaee Springmvc",
    "url": "/posts/JAVAEE-springmvc/",
    "categories": "javaEE",
    "tags": "springmvc",
    "date": "2022-11-11 00:00:00 +0800",
    "content": "springmvc          使用                      1.package &amp;lt;dependencies&amp;gt;     &amp;lt;dependency&amp;gt;         &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;         &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;..."
  },
  {
    "title": "Javaee Spring",
    "url": "/posts/JAVAEE-spring/",
    "categories": "javaEE",
    "tags": "spring",
    "date": "2022-11-04 00:00:00 +0800",
    "content": "spring          简化开发，降低企业级开发的复杂性                      目标：充分解耦                     使用IoC容器管理bean（IOC)           在IoC容器内将有依赖关系的bean进行关系绑定（DI）                                IOC(反转控制)                 ..."
  },
  {
    "title": "Javaee Docker",
    "url": "/posts/JAVAEE-docker/",
    "categories": "javaEE",
    "tags": "docker",
    "date": "2022-10-30 00:00:00 +0800",
    "content": "docker     images            docker images       docker pull       docker save -o 导出镜像到磁盘       docker rmi 删除本地的镜像           container            docker run：创建并运行一个容器，处于运行状态                    dock..."
  },
  {
    "title": "Javaee Mq_advance",
    "url": "/posts/JAVAEE-mq_advance/",
    "categories": "javaEE",
    "tags": "MQ",
    "date": "2022-10-21 00:00:00 +0800",
    "content": "异步通信          生产者消息确认             避免消息发送到MQ过程中丢失       生产者确认机制                                 返回结果有两种方式：                             publisher-confirm，发送者确认                                    消息成功..."
  },
  {
    "title": "Javaee Rabbitmq",
    "url": "/posts/JAVAEE-rabbitMQ/",
    "categories": "javaEE",
    "tags": "MQ",
    "date": "2022-10-11 00:00:00 +0800",
    "content": "MQ          AMQP                      Advanced Message Queuing Protocol,是用于在应用程序 之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求。                       public class PublisherTest {     @Test     public voi..."
  },
  {
    "title": "Javaee Mongodb",
    "url": "/posts/JAVAEE-MongoDB/",
    "categories": "javaEE",
    "tags": "MongoDB",
    "date": "2022-10-01 00:00:00 +0800",
    "content": "MongoDB  &amp;lt;parent&amp;gt;     &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;     &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;     &amp;lt;version&amp;gt;2.3.9.RELEASE&amp;lt;/version&amp;..."
  },
  {
    "title": "Javaee Redis",
    "url": "/posts/JAVAEE-redis/",
    "categories": "javaEE",
    "tags": "REDIS",
    "date": "2022-09-21 00:00:00 +0800",
    "content": "REDIS          6379      字符串 string            SET key value 					         设置指定key的值       GET key                                        获取指定key的值       SETEX key seconds value         设置指定key的值，并..."
  },
  {
    "title": "Javaee Mybatisplus",
    "url": "/posts/JAVAEE-mybatisplus/",
    "categories": "javaEE",
    "tags": "mybatisplus",
    "date": "2022-09-11 00:00:00 +0800",
    "content": "mybatisplus          &amp;lt;dependency&amp;gt;     &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt;     &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt;     &amp;lt;version&amp;gt;3.4.1&amp;lt;/version&amp;gt; &amp;..."
  },
  {
    "title": "Javaee Vue_element",
    "url": "/posts/JAVAEE-vue_element/",
    "categories": "javaEE",
    "tags": "VUE",
    "date": "2022-09-09 00:00:00 +0800",
    "content": "VUE          思想：mvvm           vue代码放到后面           指令                      v-bind                                  单向绑定                                   &amp;lt;a v-bind:href=&quot;url&quot;&amp;gt;点击一下&amp;lt;/a&amp;gt;&amp;l..."
  },
  {
    "title": "Javaee Filter_listener_ajax",
    "url": "/posts/JAVAEE-filter_listener_ajax/",
    "categories": "javaEE",
    "tags": "Filter",
    "date": "2022-08-30 00:00:00 +0800",
    "content": "Filter          使用                      实现Filter接口类                       编写@WebFilter(value=”/”)注解                       @WebFilter(filterName = &quot;demoFilter&quot;,value = &quot;/*&quot;) public class demoFilter ..."
  },
  {
    "title": "Javaee Cookie Session",
    "url": "/posts/JAVAEE-cookie-session/",
    "categories": "javaEE",
    "tags": "会话",
    "date": "2022-08-25 00:00:00 +0800",
    "content": "会话          作用             请求间共享数据                客户端会话跟踪技术：Cookie                      将数据保存到客户端                       创建cookie,发送Cookie到客户端 response.addCookie(new(&quot;key&quot;,&quot;value&quot;))                 ..."
  },
  {
    "title": "Javaee Sevelet",
    "url": "/posts/JAVAEE-sevelet/",
    "categories": "javaEE",
    "tags": "sevelet",
    "date": "2022-08-21 00:00:00 +0800",
    "content": "sevelet     使用                     1.导包                                  &amp;lt;dependency&amp;gt;     &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;     &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;g..."
  },
  {
    "title": "Javaee Maven",
    "url": "/posts/JAVAEE-maven/",
    "categories": "javaEE",
    "tags": "maven",
    "date": "2022-08-19 00:00:00 +0800",
    "content": "maven          依赖管理             gav                依赖传递                      可选依赖                                  &amp;lt;dependency&amp;gt;     &amp;lt;groupId&amp;gt;com.itheima&amp;lt;/groupId&amp;gt;     &amp;lt;artifact..."
  },
  {
    "title": "Javaee Jsp",
    "url": "/posts/JAVAEE-jsp/",
    "categories": "javaEE",
    "tags": "jsp",
    "date": "2022-08-11 00:00:00 +0800",
    "content": "jsp     脚本            &amp;lt;%…%&amp;gt;：内容会直接放到_jspService()方法之中       &amp;lt;%=…%&amp;gt;：内容会放到out.print()中，作为out.print()的参数       &amp;lt;%!…%&amp;gt;：内容会放到_jspService()方法之外，被类直接包含           原理            tomcat 会将 h..."
  },
  {
    "title": "Javase Java Update",
    "url": "/posts/javaSE-java-update/",
    "categories": "javaSE",
    "tags": "",
    "date": "2022-08-03 00:00:00 +0800",
    "content": "star    Java SE就是标准版，包含标准的JVM和标准库，而Java EE是企业版，它只是在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等，Java EE的应用使用的虚拟机和Java SE完全相同。Java ME就和Java SE不同，它是一个针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟..."
  },
  {
    "title": "Javase 多线程",
    "url": "/posts/javaSE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/",
    "categories": "javaSE",
    "tags": "多线程",
    "date": "2022-07-24 00:00:00 +0800",
    "content": "多线程          继承Thread类                      public class MyThread extends Thread {     @Override     public void run() {         for(int i=0; i&amp;lt;100; i++) {             System.out.println(i);    ..."
  },
  {
    "title": "Javase Socket",
    "url": "/posts/javaSE-socket/",
    "categories": "javaSE",
    "tags": "socket",
    "date": "2022-07-21 00:00:00 +0800",
    "content": "socket          TCP                       new ServerSocket(6666); // 监听指定端口                                 ss.accept()就返回一个Socket实例，这个Socket实例就是用来和刚连接的客户端进行通信的                       newclient.getR..."
  },
  {
    "title": "Javase 日期与时间",
    "url": "/posts/javaSE-%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4/",
    "categories": "javaSE",
    "tags": "TIME",
    "date": "2022-07-05 00:00:00 +0800",
    "content": "概念     时区            一种是以GMT或者UTC加时区偏移表示，例如：GMT+08:00或者UTC+08:00表示东八区。       另一种是缩写，例如，CST表示China Standard Time，也就是中国标准时间。但是CST也可以表示美国中部时间Central Standard Time USA，因此，缩写容易产生混淆，我们尽量不要使用缩写。          ..."
  },
  {
    "title": "Javase Io",
    "url": "/posts/javaSE-IO/",
    "categories": "javaSE",
    "tags": "IO",
    "date": "2022-07-01 00:00:00 +0800",
    "content": "File          创建文件对象                      File f1 = new File(&quot;E:\\itcast\\java.txt&quot;); File f2 = new File(&quot;E:\\itcast&quot;,&quot;java.txt&quot;); File f1 = new File(File,&quot;E:\\itcast\\java.txt&quot;);                  ..."
  },
  {
    "title": "Tensorflow Section5 词表",
    "url": "/posts/Tensorflow-section5-%E8%AF%8D%E8%A1%A8/",
    "categories": "Tensorflow",
    "tags": "词表",
    "date": "2022-06-07 00:00:00 +0800",
    "content": "tensorflow创建词表  #1.构建层，一般用于构建dataset中，使用map函数 #tf.Tensor(b&#39;First Citizen:&#39;, shape=(), dtype=string) #tf.Tensor(b&#39;Before we proceed any further, hear me speak.&#39;, shape=(), dtype=string) layer=tf.ker..."
  },
  {
    "title": "Tensorflow Section4 自定义操作",
    "url": "/posts/Tensorflow-section4-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C/",
    "categories": "Tensorflow",
    "tags": "自定义",
    "date": "2022-05-07 00:00:00 +0800",
    "content": "Tensorflow自定义          自定义损失                      函数形式                       def custom_mean_squared_error(y_true, y_pred):       return tf.math.reduce_mean(tf.square(y_true - y_pred))        model..."
  },
  {
    "title": "Tensorflow Section4 模型操作",
    "url": "/posts/Tensorflow-section4-%E6%A8%A1%E5%9E%8B%E6%93%8D%E4%BD%9C/",
    "categories": "Tensorflow",
    "tags": "模型操作",
    "date": "2022-04-27 00:00:00 +0800",
    "content": "Tensorflow模型操作          GPU设置                      os.environ[&#39;CUDA_VISIBLE_DEVICES&#39;]=&quot;0，1，2&quot; gpus=tf.config.list_physical_device(&quot;GPU&quot;) for gpu in gpus:     tf.config.experimental.set_memory_growt..."
  },
  {
    "title": "Tensorflow Section3 模型训练",
    "url": "/posts/Tensorflow-section3-%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/",
    "categories": "Tensorflow",
    "tags": "模型训练",
    "date": "2022-04-07 00:00:00 +0800",
    "content": "Tensorflow模型训练          组件库      tf.keras.layers.                搭建网络                      Sequential                                  import tensorflow as tf net = tf.keras.Sequential(         tf...."
  },
  {
    "title": "Tensorflow Section2 数据处理",
    "url": "/posts/Tensorflow-section2-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/",
    "categories": "Tensorflow",
    "tags": "数据处理",
    "date": "2022-03-17 00:00:00 +0800",
    "content": "Tensorflow数据处理          图片                      读入数据                       tf.io.read_file(img_path)      #&amp;lt;tf.Tensor: shape=(), dtype=string,numpy=b&#39;\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x00..."
  },
  {
    "title": "Tensorflow Section1 基础api",
    "url": "/posts/Tensorflow-section1-%E5%9F%BA%E7%A1%80api/",
    "categories": "Tensorflow",
    "tags": "基础知识",
    "date": "2022-03-07 00:00:00 +0800",
    "content": "Tensorflow基础api          创建Tensor             tf.convert_to_tensor(data)       tf.zeros(shape)       tf.ones()       tf.zeros_like()       tf.ones_like()       tf.full(shape,value)              tf...."
  },
  {
    "title": "Pytorch Section8 Torchtext",
    "url": "/posts/Pytorch-section8-torchtext/",
    "categories": "Pytorch",
    "tags": "text",
    "date": "2021-08-26 00:00:00 +0800",
    "content": "Torchtext     数据处理工具 torchtext.data.functional/utils   数据集 torchtext.data.datasets   词表工具 torchtext.vocab   评测指标 torchtext.metrics"
  },
  {
    "title": "Pytorch Section7 可视化",
    "url": "/posts/Pytorch-section7-%E5%8F%AF%E8%A7%86%E5%8C%96/",
    "categories": "Pytorch",
    "tags": "可视化",
    "date": "2021-08-16 00:00:00 +0800",
    "content": "Pytorch模型可视化          print(model)输出信息                      ResNet(   (conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False)   (bn1): BatchNorm2d(64, eps=1e-05, momen..."
  },
  {
    "title": "Pytorch Section6 自定义",
    "url": "/posts/Pytorch-section6-%E8%87%AA%E5%AE%9A%E4%B9%89/",
    "categories": "Pytorch",
    "tags": "自定义",
    "date": "2021-08-06 00:00:00 +0800",
    "content": "Pytorch自定义          自定义损失函数                      函数方式                                  def my_loss(output, target):     loss = torch.mean((output - target)**2)     return loss                      ..."
  },
  {
    "title": "Pytorch Section5 模型操作",
    "url": "/posts/Pytorch-section5-%E6%A8%A1%E5%9E%8B%E6%93%8D%E4%BD%9C/",
    "categories": "Pytorch",
    "tags": "模型操作",
    "date": "2021-07-06 00:00:00 +0800",
    "content": "Pytorch模型操作          迁移学习                      from torchvision import models                       修改模型的组件层                     model.layer=model                                冻结模型               ..."
  },
  {
    "title": "Pytorch Section4 模型训练 ",
    "url": "/posts/Pytorch-section4-%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83/",
    "categories": "Pytorch",
    "tags": "模型训练",
    "date": "2021-06-06 00:00:00 +0800",
    "content": "Pytorch模型训练          模型组件             torch.nn                    Con2d(in_chanal,out_chanal,kernel_size,stride,padding)           Linear(in_chanal,out_chanal, bias)           MaxPool2d(henal_size,..."
  },
  {
    "title": "Pytorch Section3 数据处理",
    "url": "/posts/Pytorch-section3-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/",
    "categories": "Pytorch",
    "tags": "数据处理",
    "date": "2021-05-06 00:00:00 +0800",
    "content": "Pytorch数据处理          数据读入             torch.utils.data                           构建DataSet(data,label)          #可以自定义,会自动中断__getitem__ class MyDataset(Dataset):     def __init__(self, data_dir, in..."
  },
  {
    "title": "Pytorch Section2 基础知识",
    "url": "/posts/Pytorch-section2-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/",
    "categories": "Pytorch",
    "tags": "基础知识",
    "date": "2021-04-16 00:00:00 +0800",
    "content": "Pytorch基础知识         创建Tensor     | 函数                |                       功能                        | | :—————— | :———————————————–: | | Tensor(shape/data)       |                   基础构造函数      ..."
  },
  {
    "title": "Pytorch Section1 环境搭建",
    "url": "/posts/Pytorch-section1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/",
    "categories": "Pytorch",
    "tags": "环境搭建",
    "date": "2021-04-06 00:00:00 +0800",
    "content": "Pytorch环境搭建    pip换源            pip.ini文件           [global]   index-url = http://pypi.douban.com/simple   [install]   use-mirrors =true   mirrors =http://pypi.douban.com/simple/   trusted-host =py..."
  },
  {
    "title": "西瓜书 第一章 机器学习绪论",
    "url": "/posts/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BB%AA%E8%AE%BA/",
    "categories": "西瓜书",
    "tags": "绪论",
    "date": "2021-03-01 00:00:00 +0800",
    "content": "机器学习绪论    假设空间            为算法模型在训练集下的所有状态的集合，每一种假设对应一种模型           版本空间            在算法模型的假设空间之中可以适应训练集的要求的假设集合           归纳偏好            对于某种类型假设的偏好，书中的等效假设应该是满足训练集的假设           奥卡姆剃须刀            归..."
  },
  {
    "title": "西瓜书 第四章 神经网络",
    "url": "/posts/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/",
    "categories": "西瓜书",
    "tags": "神经网络",
    "date": "2021-02-28 00:00:00 +0800",
    "content": "神经网络          神经元              \[y=f\bigg ( \sum^n_{i=1}w_ix_i-theata \bigg)\]                       感知机                      属性                      \[IV(a)=-\sum_{v=1}^V{|D^v| \over |D|}log_2{|D^..."
  },
  {
    "title": "西瓜书 第四章 决策树",
    "url": "/posts/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%86%B3%E7%AD%96%E6%A0%91/",
    "categories": "西瓜书",
    "tags": "决策树",
    "date": "2021-02-21 00:00:00 +0800",
    "content": "决策树          ID3信息增益划分准则                      信息熵                      \[Ent(D)=-\sum_{k=1}^{|y|}p_klog_2p_k\]                                           信息增益                      \[Gain(D,a)=Ent(D)..."
  },
  {
    "title": "西瓜书 第三章 线性模型",
    "url": "/posts/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/",
    "categories": "西瓜书",
    "tags": "线性模型",
    "date": "2021-02-14 00:00:00 +0800",
    "content": "线性模型          线性回归模型                      基本形式                      \[f(x)=\bold w^Tx+b\]                                           损失函数                      \[loss=\sum_{i}^n||y_i^*-f(x_i)||_2^2=(..."
  },
  {
    "title": "西瓜书 第二章 模型评估",
    "url": "/posts/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0/",
    "categories": "西瓜书",
    "tags": "模型评估",
    "date": "2021-01-07 00:00:00 +0800",
    "content": "模型评估    评估方法            留出法                    顾名思义就是选择一些数据留出作为测试集                            保证训练数据与测试数据分布的一致性               选择数据应为随机采样                                               k折交叉验证        ..."
  },
  {
    "title": "西瓜书 第五章 贝叶斯分类",
    "url": "/posts/%E8%A5%BF%E7%93%9C%E4%B9%A6-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB/",
    "categories": "西瓜书",
    "tags": "贝叶斯分类",
    "date": "2021-01-01 00:00:00 +0800",
    "content": "贝叶斯分类          贝叶斯分类器           假设属性之间是独立同分布       \[h(x)=argmax_c(p(c|x))\\p(c|x)={p(c)p(x|c) \over p(x)} \quad p(c)先验；\quad p(x|c)似然；\]           在使用贝叶斯分类器时，贝叶斯公式       \[p(c|x)={p(c) \over p(x)}..."
  },
  {
    "title": "Bigdata 实用脚本",
    "url": "/posts/BigData-%E5%AE%9E%E7%94%A8%E8%84%9A%E6%9C%AC/",
    "categories": "BigData",
    "tags": "脚本",
    "date": "2020-11-29 00:00:00 +0800",
    "content": "脚本     xsync   #!/bin/bash #1. 判断参数个数 if [ $# -lt 1 ] then   echo Not Enough Arguement!   exit; fi #2. 遍历集群所有机器 for host in hadoop102 hadoop103 hadoop104 do   echo ====================  $host  ====..."
  },
  {
    "title": "Bigdata Spark_sql",
    "url": "/posts/BigData-spark_sql/",
    "categories": "BigData",
    "tags": "Spark SQL",
    "date": "2020-11-28 00:00:00 +0800",
    "content": "Spark SQL     Spark SQL 通过提供基于事务的写入和批量写入来实现 Exactly-Once 语义。Spark SQL 通过使用 Catalyst 引擎和 Spark SQL 执行引擎来提供一致性和容错性。 具体来说，Spark SQL 采用基于写入事务和批量写入的方法来实现 Exactly-Once 语义。在写入数据时，Spark SQL 会创建一个事务，对于每个批次的..."
  },
  {
    "title": "Bigdata Spark_core",
    "url": "/posts/BigData-spark_core/",
    "categories": "BigData",
    "tags": "Spark core",
    "date": "2020-11-18 00:00:00 +0800",
    "content": "spark core     集群            驱动器节点（Driver Node）：驱动器节点是 Spark 应用程序的核心节点，它负责整个应用程序的流程控制和协调工作。驱动器节点通常是 Spark 应用程序的入口点，负责从输入源中读取数据，并将数据分发到集群中的工作节点上进行处理。同时，驱动器节点还负责将处理结果返回给客户端或输出到外部存储系统中。       管理节点（Mas..."
  },
  {
    "title": "Bigdata Spark内核",
    "url": "/posts/BigData-spark%E5%86%85%E6%A0%B8/",
    "categories": "BigData",
    "tags": "Spark",
    "date": "2020-11-08 00:00:00 +0800",
    "content": "Spark内核  1.Spark核心组件     Driver   Spark驱动器节点，用于执行Spark任务中的main方法，负责实际代码的执行工作。Driver在Spark作业执行时主要负责：         1.  将用户程序转化为作业（job）；                        2.  在Executor之间调度任务(task)；                   ..."
  },
  {
    "title": "Bigdata Spark_stream",
    "url": "/posts/BigData-spark_stream/",
    "categories": "BigData",
    "tags": "Spark Streaming",
    "date": "2020-10-29 00:00:00 +0800",
    "content": "Spark Streaming     Receiver 接收器会将数据存储在内存或磁盘中，然后将一定时间范围内接收到的数据组成一个数据块（batch），并将这个数据块交给 Spark Streaming 的输入流（InputDStream）。接着，输入流将这个数据块转化为一个 RDD，并将这个 RDD 作为输入数据流（DStream）的一部分         背压机制:动态控制数据接收速率..."
  },
  {
    "title": "Bigdata 数仓",
    "url": "/posts/BigData-%E6%95%B0%E4%BB%93/",
    "categories": "BigData",
    "tags": "数仓",
    "date": "2020-10-21 00:00:00 +0800",
    "content": "数仓     数仓分层            ODS层：原始数据层，存放原始数据，直接加载原始日志、数据，数据保持原貌不做处理。 化、脱敏等       DWD层：对ODS层数据进行清洗（去除空值；脏数据；超过极限范围的数据）·维度退       DWS层：以DWD为基础，按天进行轻度汇总。       DWT：以DWS为基础，按主题进行汇总。       ADS层：为各种统计报表提供数据 ..."
  },
  {
    "title": "Bigdata Hive Ddl",
    "url": "/posts/BigData-Hive-DDL/",
    "categories": "BigData",
    "tags": "Hive",
    "date": "2020-10-18 00:00:00 +0800",
    "content": "Hive  HQL转化成MapReduce程序一般Hive元数据配置到MySql     Tez引擎            Tez是一个Hive的运行引擎，性能优于MR       将tez安装包拷贝到集群，并解压tar包       上传tez依赖到HDFS       新建tez-site.xml       编辑hadoop-env.sh           用户接口：Client C..."
  },
  {
    "title": "Bigdata Hive 调优",
    "url": "/posts/BigData-Hive-%E8%B0%83%E4%BC%98/",
    "categories": "BigData",
    "tags": "Hive",
    "date": "2020-10-09 00:00:00 +0800",
    "content": "Hive     要在Hadoop中启用压缩，可以配置如下参数（mapred-site.xml文件中）：                  参数       默认值       阶段       建议                       io.compression.codecs  （在core-site.xml中配置）       org.apache.hadoop.io.comp..."
  },
  {
    "title": "Bigdata Hive Dml",
    "url": "/posts/BigData-Hive-DML/",
    "categories": "BigData",
    "tags": "Hive",
    "date": "2020-10-01 00:00:00 +0800",
    "content": "Hive     查询   1------------------ select * from emp; select empno, ename from emp;  2------------------+ A+B	A和B 相加 A-B	A减去B A*B	A和B 相乘 A/B	A除以B A%B	A对B取余 A&amp;amp;B	A和B按位取与 A|B	A和B按位取或 A^B	A和B按位取异或 ~..."
  },
  {
    "title": "Bigdata Flink_table",
    "url": "/posts/BigData-flink_table/",
    "categories": "BigData",
    "tags": "Table SQL",
    "date": "2020-09-22 00:00:00 +0800",
    "content": "Table SQL  Table API是一套内嵌在Java和Scala语言中的查询API，它允许我们以非常直观的方式，组合来自一些关系运算符的查询（比如select、filter和join）。  Flink SQL，就是直接可以在代码中写SQL，来实现一些查询（Query）操作  表（Table）是由一个“标识符”来指定的，由3部分组成：Catalog名、数据库（database）名和对象..."
  },
  {
    "title": "Bigdata Flink",
    "url": "/posts/BigData-flink/",
    "categories": "BigData",
    "tags": "Flink",
    "date": "2020-09-21 00:00:00 +0800",
    "content": "Flink          Flink运行架构             作业管理器（JobManager） 每个应用程序都会被一个不同的JobManager所控制执行。JobManager会先接收到要执行的应用程序，向资源管理器（ResourceManager）请求执行任务必要的资源，也就是任务管理器（TaskManager）上的插槽（slot）。一旦它获取到了足够的资源，就会将执行图分发..."
  },
  {
    "title": "Bigdata Zookeeper",
    "url": "/posts/BigData-zookeeper/",
    "categories": "BigData",
    "tags": "Zookeeper",
    "date": "2020-09-13 00:00:00 +0800",
    "content": "Zookeeper  分布式应用程序的分布式协调服务     角色            Leader：它负责 发起并维护与各 Follwer 及 Observer 间的心跳。所有的写操作必须要通过 Leader 完成再由 Leader 将写操作广播给其它服务器。一个 Zookeeper 集群同一时间只会有一个实际工作的 Leader。       Follower：它会响应 Leader ..."
  },
  {
    "title": "Bigdata Hbase",
    "url": "/posts/BigData-Hbase/",
    "categories": "BigData",
    "tags": "Pulsar",
    "date": "2020-09-09 00:00:00 +0800",
    "content": "Hbase  HBase是一种分布式、可扩展、支持海量数据存储的NoSQL数据库。          数据模型                      Name Space：命名空间，类似于关系型数据库的DatabBase概念，每个命名空间下有多个表。HBase有两个自带的命名空间，分别是hbase和default，hbase中存放的是HBase内置的表，default表是用户默认使用的命..."
  },
  {
    "title": "Bigdata Pulsar",
    "url": "/posts/BigData-Pulsar/",
    "categories": "BigData",
    "tags": "Pulsar",
    "date": "2020-09-03 00:00:00 +0800",
    "content": "Pulsar  Apache Pulsar 是一种新型的分布式消息队列和流处理平台，其起源于 Yahoo 开发的 PubSub 系统，后来在 2018 年成为了 Apache 基金会的顶级项目。Pulsar 的设计目标是支持高吞吐量和低延迟的消息传递，同时具备可扩展性、多租户、多数据中心部署等特点，可以满足大规模分布式系统的需求。  Pulsar 的主要特点包括：          分层架构..."
  },
  {
    "title": "Bigdata Kafka",
    "url": "/posts/BigData-Kafka/",
    "categories": "BigData",
    "tags": "Kafka",
    "date": "2020-09-01 00:00:00 +0800",
    "content": "Kafka  Kafka是一个分布式的基于发布/订阅模式的消息队列，主要应用于大数据实时处理领域          Kafka基础架构             （1）Producer ：消息生产者，就是向kafka broker发消息的客户端；       （2）Consumer ：消息消费者，向kafka broker取消息的客户端；       （3）Consumer Group （CG..."
  },
  {
    "title": "Bigdata Flume",
    "url": "/posts/BigData-flume/",
    "categories": "BigData",
    "tags": "Flume",
    "date": "2020-08-29 00:00:00 +0800",
    "content": "Flume  Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统。Flume基于流式架构，灵活简单。          Agent Agent是一个JVM进程，它以事件的形式将数据从源头送至目的。 Agent主要有3个部分组成，Source、Channel、Sink。           Source Source是负责接收数据到Flume Ag..."
  },
  {
    "title": "Bigdata Hadoop_ha",
    "url": "/posts/BigData-hadoop_HA/",
    "categories": "BigData",
    "tags": "hadoop, HA",
    "date": "2020-08-23 00:00:00 +0800",
    "content": "hadoop-HA  HDFS HA功能通过配置Active/Standby两个NameNodes实现在集群中对NameNode的热备来解决上述问题。     HDFS-HA            CHANGE                    元数据管理方式需要改变 内存中各自保存一份元数据； Edits日志只有Active状态的NameNode节点可以做写操作； 两个NameNode..."
  },
  {
    "title": "Bigdata Hadoop Hdfs",
    "url": "/posts/BigData-hadoop-HDFS/",
    "categories": "BigData",
    "tags": "hadoop, HDFS",
    "date": "2020-08-13 00:00:00 +0800",
    "content": "Hadoop-HDFS  HDFS的使用场景：适合一次写入，多次读出的场景，且不支持文件的修改。适合用来做数据分析，并不适合用来做网盘应用     shell   上传 hadoop fs -moveFromLocal hadoop fs -copyFromLocal/hadoop fs -put hadoop fs -appendToFile 下载 hadoop fs -get  hado..."
  },
  {
    "title": "Bigdata Hadoop Yarn",
    "url": "/posts/BigData-hadoop-yarn/",
    "categories": "BigData",
    "tags": "hadoop, Yarn",
    "date": "2020-08-09 00:00:00 +0800",
    "content": "hadoop-Yarn  1)ResourceManager(RM):处理客户端请求;监控NodeManager;启动或监控ApplicationMaster;资源的分配与调度 2)NodeManager(NM):营理单个节点上的资源;处理来自RM的命令;处里来ApplicationMaster的命令 3)ApplicationMaster(AM):负责数据的切分;为应用程序申请资源并分配给..."
  },
  {
    "title": "Bigdata Hadoop Mapreduce",
    "url": "/posts/BigData-hadoop-mapreduce/",
    "categories": "BigData",
    "tags": "hadoop, Mapreduce",
    "date": "2020-08-03 00:00:00 +0800",
    "content": "hadoop-Mapreduce  AppMaster:负责整个程序的过程调度及状态协调。 MapTask:负责Map阶段的整个数据处理流程。 ReduceTask:负责Reduce阶段的整个数据处理流程。     运行机制   1.InputFormat数据输入     MapTask的并行度：         1)一个Job的Map阶段并行度由客户端在提交Job时的切片数决定      ..."
  },
  {
    "title": "Machine Learing 强化学习",
    "url": "/posts/Machine-Learing-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/",
    "categories": "Machine Learing",
    "tags": "强化学习, 似然函数",
    "date": "2020-07-03 00:00:00 +0800",
    "content": "强化学习          似然函数             ​    \(\theta=argmax_\theta \{Reward\_function\}\)           PPO算法          Proximal Policy Optimization近端策略优化           目标函数表示                                    这个目..."
  },
  {
    "title": "Machine Learing Pca",
    "url": "/posts/Machine-Learing-PCA/",
    "categories": "Machine Learing",
    "tags": "PCA",
    "date": "2020-06-18 00:00:00 +0800",
    "content": "PCA          对数据集投影到向量之后的方差最大化           推导              \[\mu^T:投影向量/矩阵\quad; \mu^T*x_i：数据集x_i投影之后的向量\\ 投影之后的数据集的均值表示：{1\over n}\sum_{i=1}^{n}u^T*x_i=0;(X之前会进行均值化)\\ 投影之后的数据集的方差表示：{1\over n}\sum_{..."
  },
  {
    "title": "Machine Learing 拉格朗日对偶问题",
    "url": "/posts/Machine-Learing-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98/",
    "categories": "Machine Learing",
    "tags": "最优化, 对偶",
    "date": "2020-05-13 00:00:00 +0800",
    "content": ""
  },
  {
    "title": "Machine Learing 集成学习",
    "url": "/posts/Machine-Learing-%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/",
    "categories": "Machine Learing",
    "tags": "集成学习, Voting, Bagging, Boosting, Stacking, Random Forests",
    "date": "2020-05-11 00:00:00 +0800",
    "content": "集成学习          majority-Voting                   假设每一个分类模型的错误率只是比随机猜测好一点（错误率低于0.5)       那么k个模型输出都是错误类别，造成最终是错误类别的概率              soft-voting:加入权值                Bagging             有放回抽样构建数据集      ..."
  },
  {
    "title": "Machine Learing 矩阵求导",
    "url": "/posts/Machine-Learing-%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/",
    "categories": "Machine Learing",
    "tags": "微分学, 最大似然估计, logistic回归",
    "date": "2020-04-03 00:00:00 +0800",
    "content": ""
  },
  {
    "title": "Machine Learing 支持向量机",
    "url": "/posts/Machine-Learing-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/",
    "categories": "Machine Learing",
    "tags": "支持向量机, 拉格朗日, 松弛变量, 对偶问题",
    "date": "2020-04-01 00:00:00 +0800",
    "content": ""
  },
  {
    "title": "Nlp Section8 Transformer",
    "url": "/posts/nlp-section8-transformer/",
    "categories": "nlp",
    "tags": "transformer, self attention",
    "date": "2019-11-12 00:00:00 +0800",
    "content": "transformer          self-attention                      不同于attenstion使用输入X序列与当前Y输出的attention，self-attenstion主要是使用输入X序列直间的attention表示Y输出序列               \[Y_i=\sum_jw_{i,j}*X_i\quad w_{i,j}为X_i与X_j..."
  },
  {
    "title": "Nlp Section7 Seq2seq",
    "url": "/posts/nlp-section7-seq2seq/",
    "categories": "nlp",
    "tags": "seq2seq, attention_mask",
    "date": "2019-09-09 00:00:00 +0800",
    "content": "seq2seq     计算方式            在decode阶段的每一个rnn的y是一个可以使用交叉熵衡量损失的结果       为了不让每次只出现最大可能的结果，有防止计算量太大在greed与exhaustic中使用了beam search       beam search使用每次选择所有概率中最大的beam size个候选集           attention      ..."
  },
  {
    "title": "Nlp Section6 Rnn",
    "url": "/posts/nlp-section6-RNN/",
    "categories": "nlp",
    "tags": "RNN, LSTM",
    "date": "2019-08-11 00:00:00 +0800",
    "content": "RNN          to用近似定理 (Universal approximation theorem) 如果一个前馈神经网络具有线性输出层和至少一层隐藏层，只要给予网络足够数量的神经元，便可以实现以足够高精度来逼近任意一个在 ℝn 的紧子集 (Compact subset) 上的连续函数           为什么使用RNN：FNN的输入固定,RN共享U，W，V参数          ..."
  },
  {
    "title": "Nlp Section5 Crf",
    "url": "/posts/nlp-section5-CRF/",
    "categories": "nlp",
    "tags": "条件随机场, CRF",
    "date": "2019-07-21 00:00:00 +0800",
    "content": "条件随机场CRF          HMM                      任意时刻当前的状态只与前一个时刻的状态有关（状态转移矩阵A）                       当前观测只与当前状态有关（观测矩阵B）                       这两个假设在nlp领域不合理               \[P(X,Z)=\prod \limits_{i=1}^{..."
  },
  {
    "title": "Nlp Section4 Em与hmm",
    "url": "/posts/nlp-section4-EM%E4%B8%8EHMM/",
    "categories": "nlp",
    "tags": "最大期望, 隐马尔可夫",
    "date": "2019-06-28 00:00:00 +0800",
    "content": "最大期望算法（EM）          是一种对含有隐变量模型估计的方法           算法思路              \[argmax_\theta log(p(Y|\theta))==&amp;gt;argmax_\theta log\sum_zp(Y,Z|\theta)\]                       按照最大似然估计的算法求解使得当前的Y的出现概率最大的\theta..."
  },
  {
    "title": "Nlp Section3 Word2vector",
    "url": "/posts/nlp-section3-word2vector/",
    "categories": "nlp",
    "tags": "词向量",
    "date": "2019-06-21 00:00:00 +0800",
    "content": "词向量学习          skipgrame语言模型与CBOW类似           在skipgrame中使用单词为主题，预测单词的上下文，而CBOW中使用context预测中心词           假设相邻的单词相似度最高           使用一种无监督的方法训练(dense)词向量           定义window_size使用单词对context的单词进行预测    ..."
  },
  {
    "title": "Nlp Section2 文本表示",
    "url": "/posts/nlp-section2-%E6%96%87%E6%9C%AC%E8%A1%A8%E7%A4%BA/",
    "categories": "nlp",
    "tags": "文本表示",
    "date": "2019-05-16 00:00:00 +0800",
    "content": "文本表示     词袋模型（bag of words）            词集模型       用于表示句子中的包含的词语集合，但无上下文顺序关系、且没有对词的注意           tfidf            使用tfidf表示句子中的每个单词       tf：词频       idf：log(文档总数/包含词的文档数量)，词在文档中出现的越多，越不重要           ..."
  },
  {
    "title": "Nlp Section1 文本预处理",
    "url": "/posts/nlp-section1-%E6%96%87%E6%9C%AC%E9%A2%84%E5%A4%84%E7%90%86/",
    "categories": "nlp",
    "tags": "预处理",
    "date": "2019-04-08 00:00:00 +0800",
    "content": "文本预处理     分词            最大匹配                    前向           后向                       语言模型                    生成所有可能的分词，选择概率最大的，这个概率可以是unigrame或者bigrame           统计数据概率                           纠..."
  }
  
]

