---
categories: [redis]
tags: [redis]
---
# 设计行为1：复制

## 旧版复制的实现

**Redis的复制功能分为** **同步（sync）** **和** **命令传播（commandpropagate）** **两个操作：**

* **同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。**
* **命令传播操作则用于在** **主服务器的数据库状态被修改** **，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。**

**（1）同步**

**从服务器对主服务器的同步操作需要通过**向主服务器**发送**SYNC命令来完成，以下是SYNC命令的执行步骤：

1. **从服务器向主服务器发送SYNC命令**
2. **主服务器收到后，执行BGSAVE命令，生成RDB文件，并使用缓冲区记录现在开始执行的所有写命令。**
3. **将RDB文件发送给从服务器，从服务器收到后更新**
4. **主服务器将缓冲区的内容发送给从服务器，从服务器收到后更新。**

**BGSAVE命令会** **增加一个子进程** **，负责创建RDB文件。**

![](https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200110102512.png)

**（2）命令传播：**在** **命令传播阶段** **，从服务器默认会以每秒一次的频率，向主服务器发送命令****

**主服务器会将自己执行的** **写命令** **，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。**

![](https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200110103530.png)

## 旧版复制的缺陷

**在Redis中，从服务器对主服务器的复制可以分为以下两种情况：**

* **初次复制** **：从服务器以前没有复制过任何主服务器，或者要复制的主服务器和上一次复制的主服务器不同。**
* **断线后重复制** **：处于命令传播阶段的主从服务器因为网络原因而中断了复制，但从服务器通过自动重连接重新连上了主服务器，并继续复制主服务器。**

**初次复制效果挺好的，但断线后重新复制效率就很低。因为执行SYNC命令是非常消耗资源的行为。**

## 新版复制功能

**从2.8版本开始**

**PSYNC命令具有** **完整重同步（full resynchronization）** **和** **部分重同步（partial resynchronization）** **两种模式：**

* **完整重同步用于初次复制，和SYNC命令完全一致**
* **部分重同步，将断线后的命令发送给从服务器。**

---

**要实现部分重同步，需要完成三个部分：**

* **主服务器的** **复制偏移量** **（replication offset）和从服务器的复制偏移量。**
* **主服务器的** **复制积压缓冲区** **（replication backlog）。**
* **服务器的** **运行ID** **（run ID）。**

**（1）复制偏移量**

**主服务器和从服务器会分别维护一个复制偏移量：**

* **主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N。**
* **从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。**

 **通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态** **：**

* **如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的。**
* **相反，如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态。**

**（2）复制积压缓冲区**

**复制积压缓冲区是由主服务器维护的一个** **固定长度** **（fixed-size）先进先出（FIFO）队列，默认大小为1MB。当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会** **将写命令入队到复制积压缓冲区里面** **。与此同时，主服务器也会向积压缓冲区添加偏移量，**

**当服务器重新连接上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，** **主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作** **：**

* **offset偏移量之后的数据仍然存在于复制积压缓冲区中，主服务器执行部分重同步操作**
* **反之，偏移量之后的数据已不存在于复制积压缓冲区，则执行完整重同步。**

**复制积压缓冲区作为一个****限制性容器**保证了复制的高效性：

* **如果断线时间短，错过的命令少，则直接调用偏移量为从服务器补上命令**
* **反之，则直接完全重同步。**

**（3）服务器运行ID**

**每个Redis服务器，不论主服务器还是从服务，都会有自己的运行ID，运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成。**

**当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来。**

**当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID：**

* **如果ID相同，则表示** **之前同步的主服务器就是这个** **，执行部分重同步。**
* **如果ID不同，则表明从** **服务器断线之前复制的主服务器并不是当前连接的这个主服务器** **，执行完整重同步操作。**

# 设计行为2：集群

## **槽指派**

**Redis集群通过分片的方式来保存数据库中的键值对：** **集群的整个数据库被分为16384个槽（slot）** **，** **数据库中的每个键都属于这16384个槽的其中一个** **，集群中的每个节点可以处理0个或最多16384个槽。**

**当数据库中的16384个槽***都有*节点在处理时， **集群处于上线状态（ok）** **；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态（fail）。**

**换句话说，只有完全分配了16384个槽才会进入上线状态。**

```c
slot_number = CRC16(key)&16383
```

## **MOVED错误**

当客户端接收到节点返回的MOVED错误时，客户端会根据MOVED错误中提供的IP地址和端口号，转向至负责处理槽slot的节点，并向该节点重新发送之前想要执行的命令。

```c
127.0.0.1:7000> SET msg "happy new year!"
-> Redirected to slot [6257] located at 127.0.0.1:7001OK
```

## **设置从节点**

**和主从服务器的关系非常相似，不过** **在集群模式下服务器被替换为节点。** **Redis集群中的节点分为主节点（master）和从节点（slave），其中主节点用于处理槽，而从节点则用于复制某个主节点，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。**

## **故障检测**

**集群中的每个节点都会定期地向集群中的其他节点发送PING消息，如果接收PING消息的节点没有在规定的时间内返回PONG，那么发送PING消息的节点就会将接收PING消息的节点***标记为疑似下线（probable fail，PFAIL）*。**如果在一个集群里面，****半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为已下线（FAIL****），将主节点x标记为已下线的节点****会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线。**

## **故障转移**

**当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移的执行步骤：**

1. **从已下线主节点中选出一个从节点**
2. **从节点执行SLAVEOF no one命令，成为新的主节点**
3. **新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。**
4. **新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点。**
5. **新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。**

# 设计行为3：Sentinel

**Sentinel** **本质上只是一个运行在特殊模式下的Redis服务器** **，所以启动Sentinel的第一步，就是初始化一个普通的Redis服务器。**

## **启动与初始化**

**一个Sentinel启动时，需要执行以下步骤：**

1. **初始化服务器**
2. **将普通Redis服务器使用的代码替换成Sentinel专用代码。**
3. **初始化Sentinel状态**
4. **根据给定的配置文件，初始化Sentinel的监视主服务器列表**

   1. **Sentinel状态中的masters字典记录了所有被Sentinel监视的主服务器的相关信息，其中：**

   * **字典的****键**是**被监视主服务器**的名字。
   * **而字典的****值**则是**被监视主服务器**对应的 `<span class="ne-text">sentinel.c/sentinelRedisInstance</span>`结构。

   **每个** `<span class="ne-text">sentinelRedisInstance</span>`结构（后面简称“实例结构”） **代表一个被Sentinel监视的Redis服务器实例（instance）** **，这个实例可以是主服务器、从服务器，或者另外一个Sentinel。**

   **对Sentinel状态的初始化将引发对masters字典的初始化，而masters字典的初始化是根据被载入的Sentinel配置文件来进行的。**
5. **创建连向主服务器的网络连接**

## **获取服务器信息**

**Sentinel默认会以每十秒一次的频率，通过命令连接向被监视的** **主服务器发送INFO命令** **，并通过分析INFO命令的回复来获取主服务器的当前信息。**

```html
#Server
...
run_id:7611c59dc3a29aa6fa0609f841bb6a1019008a9c
...
# Replication
role:master...
slave0:ip=127.0.0.1,port=11111,state=online,offset=43,lag=0
slave1:ip=127.0.0.1,port=22222,state=online,offset=43,lag=0
slave2:ip=127.0.0.1,port=33333,state=online,offset=43,lag=0
...
# Other sections
```

**当Sentinel发现主服务器有新的从服务器出现时，Sentinel除了会为这个新的从服务器创建相应的实例结构之外，Sentinel还会创建连接到从服务器的命令连接和订阅连接。**

```html
# Server
...
run_id:32be0699dd27b410f7c90dada3a6fab17f97899f
...
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
master_link_status:up
slave_repl_offset:11887
slave_priority:100
# 
Other sections
...
```

## **接收主从服务器的频道**

对于每个与Sentinel连接的服务器，Sentinel既通过命令连接向服务器的 `__sentinel__:hello`频道发送信息，又通过订阅连接从服务器的 `__sentinel__:hello`频道接收信息

![img](https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200110151759.png)

![](https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200110152455.png)

## **Sentinel互相监督**

**当Sentinel通过频道信息发现一个新的Sentinel时，它不仅会为新Sentinel在sentinels字典中创建相应的实例结构** **，还会创建一个连向新Sentinel的命令连接** **，而** **新Sentinel也同样会创建连向这个Sentinel的命令连接** **，最终监视同一主服务器的多个Sentinel将形成相互连接的** **环形网络** **。**

![](https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200111102611.png)

**注意：Sentinel之间** **只会创建命令连接，但不会创建订阅** **。Sentinel需要通过接收主服务器或者从服务器发来的频道信息来发现未知的新Sentinel，所以才需要建立订阅连接。相互已知的Sentinel只要使用命令连接来进行通信就足够了。**

## 主观下线/客观下线

**Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（包括** **主服务器、从服务器、其他Sentinel在内** **）发送PING命令，并通过实例返回的PING命令回复来**判断对方是否在线。

**当对方超过一段时间不向Sentinel回复时（比如超时5000毫秒）则Sentinel1就会** **将对方标记为主观下线** **。**

**当Sentinel将一个主服务器判断为主观下线之后，为了确认这个主服务器是否真的下线了，它会** **向同样监视这一主服务器的其他Sentinel进行询问，看它们是否也认为主服务器已经进入了下线状态** **。当Sentinel从其他Sentinel那里接收到足够数量的已下线判断之后，Sentinel就会将从服务器** **判定为客观下线** **，并对主服务器执行故障转移操作。**

## **下线后的补救**

**1.选举Sentinel领袖**

一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，**选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作。**

**选举策略：**

* **候选人** **：所有在线的Sentinel**
* **选举过程** **：一个Sentinel向另一个Sentinel发送设置请求** `SENTINEL is-master-down-by-addr`命令
* **胜选条件** ：
  * **局部领头Sentinel：先到先得** **，最先向目标Sentinel发送设置要求的源Sentinel将成为目标Sen-tinel的局部领头Sentinel，而之后接收到的所有设置要求都会被目标Sentinel拒绝。**
  * **领头Sentinel：** **如果有某个Sentinel**被半数以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel。
* **重选条件：** **如果没有过半，则再次投票，知道选出过半的为止。**

2.选择从服务器为主服务器

1. **从已下线的主服务器的从服务器中**拔举一个作为主服务器。
   1. **选出偏移量最大（保存最新数据）的从服务器作为新的主服务器。** **然后向这个从服务器发送**SLAVEOF no one命令，将这个从服务器转换为主服务器。
2. **让已下线主服务器属下的所有从服务器改为复制新的主服务器**
3. **将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。**
