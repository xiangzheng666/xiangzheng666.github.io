---
categories: [javaEE]
tags: [事务]
---
# Seata

- 分布式事务解决方案

  - BASE理论

    BASE理论是对CAP的一种解决思路

    - **Basically Available** **（基本可用）**：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。
    - **Soft State（软状态）：**在一定时间内，允许出现中间状态，比如临时的不一致状态。
    - **Eventually Consistent（最终一致性）**：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。

- **TC (Transaction Coordinator) -** **事务协调者：**维护全局和分支事务的状态，协调全局事务提交或回滚。

- **TM (Transaction Manager) -** **事务管理器：**定义全局事务的范围、开始全局事务、提交或回滚全局事务。

- **RM (Resource Manager) -** **资源管理器：**管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。

- 分布式事务解决方案

  - XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入

    - 一阶段：

      - 事务协调者通知每个事物参与者执行本地事务
      - 本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有数据库锁

      二阶段：

      - 事务协调者基于一阶段的报告来判断下一步操作
        - 如果一阶段都成功，则通知所有事务参与者，提交事务
        - 如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务
    
    - ```
    seata:
        data-source-proxy-mode: XA
     
      全局事务的入口方法添加@GlobalTransactional注解
      ```
  
      
  
  - TCC模式：最终一致的分阶段事务模式，有业务侵入
  
    - Try：资源的检测和预留； 
  
    - Confirm：完成资源操作业务；要求 Try 成功 Confirm 一定要能成功。
  
    - Cancel：预留资源释放，可以理解为try的反向操作。
  
      - 空回滚
        - 当某分支事务的try阶段**阻塞**时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel不能做回滚，就是**空回滚**。
  
      - 业务悬挂
        - 对于已经空回滚的业务，之前被阻塞的try操作恢复，继续执行try，就永远不可能confirm或cancel ，事务一直处于中间状态，这就是**业务悬挂**。
  
  - AT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式
  
    - 一阶段：
      - TM发起并注册全局事务到TC
      - TM调用分支事务
      - 分支事务准备执行业务SQL
      - RM拦截业务SQL，根据where条件查询原始数据，形成快照。
      - RM执行业务SQL，提交本地事务，释放数据库锁。此时 `money = 90`
      - RM报告本地事务状态给T
    - 二阶段：
      - TM通知TC事务结束
      - TC检查分支事务状态
      - 如果都成功，则立即删除快照
      - 如果有分支事务失败，需要回滚。
      - 读取快照数据，将快照恢复到数据库。此时数据库再次恢复为100
  
  - SAGA模式：长事务模式，有业务侵入
  
    - Saga模式（也称为补偿事务模式）是一种处理分布式事务的模式，它采用一系列的本地事务来完成整个分布式事务。每个本地事务都会发出一些消息来通知其它本地事务，以便让它们决定是否需要撤销之前执行的操作。如果一个本地事务失败了，它会触发一系列的补偿操作，以撤销之前已经执行的操作。
  
    - TCC模式（Try-Confirm-Cancel模式）则是一种基于“预留”机制的分布式事务处理模式。在TCC模式中，分布式事务会被拆分为多个阶段，每个阶段都有对应的Try/Confirm/Cancel操作，Try操作会尝试执行本地事务，如果所有的Try操作都成功，则进入Confirm阶段，所有的事务最终提交。如果有任何一个Try操作失败，则进入Cancel阶段，所有的事务都被回滚。
  
      因此，尽管Saga模式和TCC模式都是解决分布式事务问题的模式，它们的实现方式、思路和适用场景都有所不同。