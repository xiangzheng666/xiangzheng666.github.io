---
categories: [redis]
tags: [redis]
---
# 设计行为1：事务

Redis通过MULTI、EXEC、WATCH等命令来实现事务（transaction）功能。事务将 一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，*服务器不会中断事务*而改去执行其他客户端的命令请求。

## 事务的实现

（1）事务开始

通过MULTI命令可以将执行该命令的客户端 从非事务状态切换至事务状态 ，这一切换是通过在客户端状态的flags属性中打开REDIS_MULTI标识来完成的。

当一个客户端已经处于非事务状态时，这个客户端发送的 命令会被服务器执行 。然而当切换到事务状态后，服务器会根据这个客户端发来的不同命令执行不同的操作：

* 如果客户端发送EXEC，DISCARD，WATCH，MULTI这四个命令，则立即执行。
* 如果发送的是其他命令，则放到事务队列里面，向客户端返回QUEUED回复。

![](https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200107143029.png)

（2）命令入队

事务的关键实现在于 命令入队 ，每个Redis客户端都有自己的 事务状态 ，这个事务状态保存在客户端状态的mstate属性里面：

```c
typedef struct redisClient
{
    //...
    multiState mstate;
    //...
}
```

而事务状态结构体又包含了一个 事务队列 ，以及一个 已入队命令的计数器 。

```c
typedef struct multiState 
{ 
    // 事务队列，FIFO顺序 
    multiCmd *commands; 
    // 已入队命令计数 
    int count;
} multiState;
```

事务队列是一个结构体，实现了队列数据结构，执行FIFO先进先出的策略。真实结构是一个数组。

```c
typedef struct multiCmd 
{ 
    // 参数 
    robj **argv; 
    // 参数数量
    int argc; 
    // 命令指针 
    struct redisCommand *cmd;
} multiCmd;
```

事务结构具体的包含逻辑是：客户端->事务状态multiState->事务队列multiCmd->具体命令cmd

![](https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200107145421.png)

（3）执行事务

当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。

1. 创建空白回复队列
2. 抽取一条命令，读取参数、参数个数以及要执行的函数
3. 执行命令，取得返回值
4. 将返回值追加到1中的队列末尾，重复步骤2

完成所有命令后，将 清除REDIS_MULTI标志 ，让客户端变为非事务状态，同时清零入队命令计数器，并释放事务队列。

## **WATCH命令**

**它可以** **在EXEC命令执行之前** **，** **监视任意数量的数据库键** **，并在EXEC命令执行时，** **检查被监视的键是否至少有一个已经被修改过了** **，** **如果是的话，服务器将拒绝执行事务** **，并向客户端返回代表事务执行失败的空回复。**

```shell
redis-> WATCH "name"
OK

redis-> MULTI
OK

redis-> SET "name" "peter"
QUEUED

redis-> EXEC
(nil)
```

**下图说明：c1和c2客户端正在监视键"name"，c3客户端正在监视"age"....**

![](https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200107152901.png)

监视触发:**对数据库执行修改命令**时 `watched_keys`字典进行检查。**查看当前命令修改的键是否在** `watched_keys` **字典中**，如果有，则客户端的 `REDIS_DIRTY_CAS`标识打开 **，表示该客户端的事务安全性已经被破坏**

**当服务器接收到一个客户端发来的EXEC命令时，服务器会根据这个客户端是否打开了** `REDIS_DIRTY_CAS`标识来决定是否执行事务。

* **如果标志被打开，则说明哨兵监视的键中被修改过了，所以当前提交的事务不再安全，拒绝执行客户端提交的事务。**
* **反之，是安全的，继续执行。**

**（1）原子性**

**所谓原子性就是某个操作不可再分，比如汇编语言里面的** `MOV DST,SRC`。事务的定义就是：将多个命令打包成一个实现， **要么全部执行，要么都不执行** **。** **在命令入队的时候，用WATCH进行检查** **，不符合要求就直接返回。**

**Redis的事务和传统的关系型数据库事务的最大区别在于，** **Redis不支持事务回滚机制（rollback）** **。作者认为Redis追求简单高效，回滚机制太复杂。**

**回滚(rollback)是指当事务中某一条命令执行出错时，意味着前面的命令可能也不安全，这时候就会释放掉前面的操作，恢复到执行事务之前的状态。MySQL数据库支持回滚操作。**

**（2）一致性**

**“** **一致”指的是数据符合数据库本身的定义和要求，没有包含非法或者无效的错误数据。** **如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。Redis保证一致性的方法如下：**

* **入队错误** **：事务入队时命令格式不正确，则Redis拒绝执行**
* **执行错误** **：执行时操作不正确，会被服务器识别，并做错误处理，所以这些出错命令不会对数据库做任何修改**
* **服务器停机** **：停机分三种情况， **
* **无持久化：重启后清空，数据总是一致的**
* **RDB模式：根据RDB恢复数据，还原为一致状态**
* **AOF模式：根据AOF恢复数据，还原为一致状态**

**（3）隔离性**

**隔离性也可被理解为** **不存在竞争** **。即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响。**

**因为Redis使用单线程**的方式来执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间 **不会对事务进行中断** **。这种**串行的方式保证了事务也总是具有隔离性的。

**（4）耐久性**

**事务的耐久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经** **被保存到永久性存储介质** **（比如硬盘）里面了，即使服务器在事务执行完毕之后停机，执行事务所得的结果也不会丢失。**

**Redis事务只是简答包裹了一组Redis命令，耐久性由持久化实现。前面提到持久化分不同的情况**

* **RDB模式下，只有特定条件被满足时才会执行BGSAVE，具有耐久性。**
* AOF模式根据appendfsync选项来决定
* **always，每次执行命令后都会调用同步函数，具有耐久性。**
* **everysec，每一秒才会同步到硬盘，不具有耐久性。**
* **no，程序会交由操作系统来决定何时将命令数据同步到硬盘。不具有耐久性。**

---

**总的来说，Redis事务**一定**具有原子性，一致性和隔离性，但**只有在特定条件下才具有耐久性。

# 设计行为2：发布与订阅

```shell
SUBSCRIBE "news.it"
```

## 频道的订阅与退订

**Redis将所有频道的订阅关系都保存在服务器状态的** `pubsub_channels`**字典**里面，这个字典的 **键是某个被订阅的频道** **，而键的** **值则是一个链表** **，链表里面记录了所有订阅这个频道的客户端。**

**看下图，不同客户端订阅了不同频道：**

![](https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200107130819.png)

---

订阅的原理是：**服务器将客户端与被订阅频道在 `pubsub_channels`字典中进行关联。**

**假如客户端10086执行命令：**

```c
SUBSCRIBE "news.sport" "news.movie"
```

**服务器完成两件事：**

* **将10086添加到sport链表后面**
* **新增一个键"news.movie"**

![](https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200107131546.png)

---

**退订就是在链表中删除客户端信息，如果退订后某个键没有任何客户端，则****程序将从pubsub_channels字典中删除频道对应的键。**

## 模式的订阅与退订

**类似地，服务器也将所有模式的订阅关系都保存在服务器状态的** `<span class="ne-text">pubsub_patterns</span>`属性。

**与频道不同的是，这是一个** **链表** **，链表中的每个节点都包含着一个** `<span class="ne-text">pubsubPattern</span>`结构，这个结构的 `<span class="ne-text">pattern</span>`属性记录了被订阅的模式，而 `<span class="ne-text">client</span>`属性则记录了订阅模式的客户端：

```c
typedef struct pubsub_Pattern 
{ 
    // 订阅模式的客户端 
    redisClient *client;
    // 被订阅的模式 
    robj *pattern;
} pubsubPattern;
```

**下面举一个例子：**

* **客户端7正在订阅模式"music.*"**
* **客户端8正在订阅模式"book.*"**
* **客户端9正在订阅模式"news.*"**

![](https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200107132321.png)

---

**订阅模式时，服务器会对每个被订阅的模式执行以下两个操作：**

1. **新建一个** `pubsubPattern`结构，将结构的 `pattern`属性设置为被订阅的模式，`client`属性设置为订阅模式的客户端。
2. **将** `pubsubPattern`结构添加到 `pubsub_patterns`链表的表尾。

![](https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200107132636.png)

**退订时，在** `pubsub_patterns`链表中查找并删除。

## 发布消息

**发布消息有两个动作：**

1. **将消息发送给所有channel的订阅者。**
2. **如果有一个或多个模式与频道channel匹配，则同时将消息发送给模式的订阅者。**

 **对于频道订阅者** **，首先服务器要在** `pubsub_channels`中找到相对应的channel(一个链表)，然后顺着这个链表，将消息发送给所有客户端。

 **对于模式订阅者** **，服务器会在** `pubsub_patterns`链表中找到 **与channel频道相匹配的模式** **，然后将消息发送给订阅了这些模式的所有客户端。**

## 查看订阅消息

**PUBSUB**命令是Redis 2.8新增加的命令之一， **客户端可以通过这个命令来查看频道或者模式的相关信息** **，比如某个频道目前有多少订阅者，又或者某个模式目前有多少订阅者。本节介绍这个命令的实现方法。**

# 设计行为3：数据库键

![img](https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200104103307.png)

![](https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200104105103.png)

### **过期键设计**

**通过**EXPIRE命令**或者 **PEXPIRE命令** 客户端可以以秒或者毫秒**精度某个键设置 **生存时间（Time To Live，TTL）** **，在经过指定的秒数或者毫秒数之后，服务器就会** **自动删除生存时间为0的键** **：**

![](https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200104130057.png)

## 过期键的删除策略

* **定时删除：在设置键的过期时间的同时，创建一个定时器（timer），定时结束后删除。**
* **惰性删除：放着不管，每次从键空间获取时检查是否过期，过期就删除。**
* **定期删除：每隔一段时间，程序检查一次数据库，删除过期键。**

**（1）定时删除**

**定时删除** **有利于内存管理** **，但** **对CPU不友好** **。如果过期键太多，删除会占用相当一部分CPU。**

**所以策略应该是：当有大量命令请求服务器处理时，并且服务器内存充足，就应该优先将CPU资源安排在处理客户端请求上，而不是删除过期键。**

**创建一个定时器需要用到Redis服务器中的** **时间事件** **，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为**![](https://www.yuque.com/api/services/graph/generate_redirect/latex?O(N))，并 **不能高效地处理大量时间事件** **。**

**（2）惰性删除**

 **对CPU最友好** **，** **但浪费内存** **。如果数据库中有很多过期键，而这些过期键永远也不会被访问的话，他们就会永远占据空间，可视为** **内存泄漏** **。**

**一些和时间有关的数据，比如日志，在某个时间点后，他们的访问就会很少。如果这类过期数据大量积压，会造成严重的内存浪费。**

**（3）定期删除**

**定期删除是一种折中，通过选择较为空闲的时间点来处理过期键，减少CPU压力。同时也能及时释放内存，避免内存泄漏。**

---

**在Redis中，** **实际使用的是惰性删除和定期删除这两种** **。**

**（1）Redis中的惰性删除**

**存在于** `<span class="ne-text">db.c/expireIfNeeded</span>`函数。**所有读写数据库的Redis命令在执行之前都会调用** `<strong><span class="ne-text">expireIfNeeded</span></strong>` **函数对输入键进行检查** **：**

* **过期，函数将输入键删除**
* **不过期，函数不动作**

**（2）Redis中的定期删除**

**过期键的定期删除策略由** `<span class="ne-text">redis.c/activeExpireCycle</span>`函数实现，**每当Redis的服务器周期性操作** `<strong><span class="ne-text">redis.c/serverCron</span></strong>` **函数执行时** **，**`<span class="ne-text">activeExpireCycle</span>`函数就会被调用，它在规定的时间内， **分多次遍历服务器中的各个数据库** **，从数据库的expires字典中** **随机检查一部分键的过期时间** **，并删除其中的过期键。**

**全局变量** `<span class="ne-text">current_db</span>`会**记录当前** `<strong><span class="ne-text">activeExpireCycle</span></strong>` **函数检查的进度** **，并在** **下一次检查时接着上一次的进度进行处理** **。比如说，如果当前** `<span class="ne-text">activeExpireCycle</span>`函数在遍历10号数据库时返回了，那么下次就会从11号数据库开始工作。

**如果所有数据库都被检查了一遍，则** `<span class="ne-text">current_db</span>`将会被置0，然后开始新一轮检查。

# 设计行为4：持久化

## **RBD持久化**

* **RDB持久化产生的RDB文件(Redis Database)是一个** **经过压缩的二进制文件，该文件可以被还原为数据库状态** **，所以即使服务器停机，服务器的数据还是被安全保存在硬盘中。**
* 有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE (BackGround SAVE)。

  * SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求；
  * **BGSAVE命令会** **增加一个子进程** **，负责创建RDB文件。**

**完整的RDB文件如下，**

![](https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200104162540.png)

**RDB是一个二进制文件而不是文本文件。**

**广义来说，所有文件都是二进制文件。狭义来说，文本文件是基于字符编码的文件，常见的编码有ASCII编码，UNICODE编码**等等；二进制文件是基于值编码的文件，也可以理解为**自定义编码。**

* *开头的REDIS占5个字节，这5个字符*用于检查是不是RDB文件。
* **db_version长度为4字节，值被解析为** **RDB版本** **，比如"0006"就代表第6版。**
* **database部分包含着** **多个数据库的键值对数据** **，根据大小不同，长度有所不同。**
* **EOF占1个字节，结束位标志。**
* **check_sum是占8字节，保存** **校验和** **。服务器在载入时会根据读入的实际数据计算出一个数来和校验值比较，以此来检查是否有损坏。**

## **AOF持久化**

**AOF如其名所示，Append Only File，AOF持久化功能的实现可以分为**命令追加（append）、文件写入与同步sync

**（1）命令追加**

**如果AOF被打开，则服务器执行完一个命令后，会以协议格式将命令** **追加到服务器状态aof_buf缓冲区的结尾** **：**

**比如执行了** `SET KEY VALUE`后，会将加载到aof_buf缓冲区

**（2）AOF文件的写入与同步**

**Redis的服务器进程就是一个** **事件循环（loop）** **，这个循环中的** **文件事件负责接收客户端的命令请求** **，** **以及向客户端发送命令回复** **，而**时间事件则负责执行像 `serverCron` **函数这样需要定时运行的函数** **。**

**服务器每次结束一个事件循环之前，它都会调用** `flushAppendOnlyFile`函数，**考虑是否需要将** `aof_buf` **缓冲区中的内容写入和保存到AOF文件里面** **。**

![img](https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200105120013.png)

这个函数的行为有服务器配置的 `appendfsync`选项来设置，默认为 `everysec`

![](https://bucket-1259555870.cos.ap-chengdu.myqcloud.com/20200105120224.png)

**默认情况下，距离上次同步过了一秒钟，则服务器会将aof_buf内容写入AOF文件中。**

### **AOF还原**

**步骤如下：**

1. **创建一个不带网络连接的** **伪客户端（fake client）** **：因为Redis的命令只能在客户端上下文中执行。**
2. **从AOF中读出一条命令。**
3. **使用伪客户端执行被读出的写命令。**
4. **重复23步**

### AOF重写

随着时间的增长，AOF文件的大小将会越来越大。为了解决这个问题，Redis提供了AOF重写功能。

重写后，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件保存的数据库状态完全相同。

如果要保存一个键值对，我们其实只关心它当前的状态。所以重写策略是：首先从数据库中读取键现在的值，然后用一条命令去记录键值对，用到了aof_rewrite函数。

比如，对list进行RPUSH操作填入"A"、"B"、"C"，然后再LPOP一次，我们操作了4次，但其实用RPUSH list A B这一条指令就可以代替。

aof_rewrite函数包含了大量写入操作，调用时会导致线程被长时间阻塞，所以Redis将AOF重写放入子进程里。

还有一个问题：子进程AOF重写时，主进程也在写命令，导致两者状态不一致。因此，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。

换句话说，子进程执行AOF期间，服务器进程需要：

* 执行客户端指令
* 将执行后的命令追加到AOF缓冲区
* 将执行后的命令追加到AOF重写缓冲区

子进程执行完AOF后，向父进程发送一个信号。父进程接收后：

1将AOF重写缓冲区的内容写入AOF文件中，保证一致性。
2对新AOF文件改名，原子的(atomic)覆盖现有AOF文件。

在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其他时候，AOF后台重写都不会阻塞父进程，这将AOF重写对服务器性能造成的影响降到了最低。
